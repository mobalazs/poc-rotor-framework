' constants
import "engine/constants.bs"

' engine
import "engine/builder/builder.bs"
import "engine/services/i18n.bs"
import "engine/providers/dispatcherProvider.bs"
import "engine/providers/dispatcherFacade.bs"
import "engine/animator/animator.bs"

' base classes
import "base/baseWidget.bs"
import "base/dispatcher.bs"
import "base/dispatcherExternal.bs"
import "base/baseReducer.bs"
import "base/baseModel.bs"
import "base/baseStack.bs"
import "base/baseViewModel.bs"

' utils
import "utils/generalUtils.bs"
import "utils/nodeUtils.bs"
import "utils/arrayUtils.bs"

' plugins
import "plugins/dispatcherProviderPlugin.bs"
import "plugins/fieldsPlugin.bs"
import "plugins/fontStylePlugin.bs"
import "plugins/observerPlugin.bs"
import "plugins/focusPlugin.bs"

namespace Rotor

    '''''''''
    ' ▗▄▄▖  ▗▄▖▗▄▄▄▖▗▄▖ ▗▄▄▖     ▗▄▄▄▖▗▄▄▖  ▗▄▖ ▗▖  ▗▖▗▄▄▄▖▗▖ ▗▖ ▗▄▖ ▗▄▄▖ ▗▖ ▗▖
    ' ▐▌ ▐▌▐▌ ▐▌ █ ▐▌ ▐▌▐▌ ▐▌    ▐▌   ▐▌ ▐▌▐▌ ▐▌▐▛▚▞▜▌▐▌   ▐▌ ▐▌▐▌ ▐▌▐▌ ▐▌▐▌▗▞▘
    ' ▐▛▀▚▖▐▌ ▐▌ █ ▐▌ ▐▌▐▛▀▚▖    ▐▛▀▀▘▐▛▀▚▖▐▛▀▜▌▐▌  ▐▌▐▛▀▀▘▐▌ ▐▌▐▌ ▐▌▐▛▀▚▖▐▛▚▖
    ' ▐▌ ▐▌▝▚▄▞▘ █ ▝▚▄▞▘▐▌ ▐▌    ▐▌   ▐▌ ▐▌▐▌ ▐▌▐▌  ▐▌▐▙▄▄▖▐▙█▟▌▝▚▄▞▘▐▌ ▐▌▐▌ ▐▌
    ' Rotor Framework™               © 2025 Balázs Molnár. All rights reserved.
    '''''''''
    class Framework

        name = "Rotor Framework"
        version = "0.2.2"

        config = {
            tasks: [], ' required
            onTaskReady: invalid, ' optional
            rootNode: invalid, ' optional

            debug: {
                autoSetNodeId: false
            },

            plugins: [
                new Rotor.FieldsPlugin("fields"),
                new Rotor.FontStylePlugin("fontStyle"),
                new Rotor.FocusPlugin("focus")
                new Rotor.DispatcherProviderPlugin("dispatcher"),
                new Rotor.ObserverPlugin("observer")
            ]
        }

        threadType = Rotor.Const.ThreadType.RENDER

        ' subsystems
        builder as object
        i18nService as object
        dispatcherProvider as object
        animatorProvider as object
        info = {
            device: {}
        }

        ' plugin adapter workspace
        plugins = {}

        ' sync
        taskOperationalFlag = {}
        taskSyncReadyFlag = {}
        taskNodes = {}

        enableRendering = true

        sub new(config = {})

            Rotor.Utils.deepExtendAA(m.config, config)

            m.builder = new Rotor.ViewBuilder.Builder()
            m.i18nService = new Rotor.ViewBuilder.I18nService()
            m.animatorProvider = new Rotor.Animator()
            m.dispatcherProvider = new Rotor.DispatcherProvider(m.threadType)

            globalScope = GetGlobalAA()
            globalScope.rotor_framework_helper = {
                threadType: m.threadType,
                frameworkInstance: m
            }

            m.initInfo()

            m.builder.init(m)
            m.i18nService.init(m)

            ' set root node
            if m.config.rootNode = invalid
                rootNode = globalScope.top
                m.config.rootNode = rootNode
            else
                rootNode = m.config.rootNode
            end if
            m.builder.widgetTree.setRootNode(rootNode)

            ' Prepare render for syncing with tasks
            rootNode.addField("rotorSync", "assocarray", true)
            rootNode.observeFieldScoped("rotorSync", "Rotor_syncCallback")

            ' prepare tasks for syncing
            if config.tasks <> invalid
                m.enableRendering = false ' disable rendering until task sync ready, then call renderQueueFlush()
                taskNames = Rotor.Utils.ensureArray(config.tasks)
                for each taskName in taskNames
                    m.setupTaskForSyncing(taskName)
                end for
            end if

            ' Register plugins
            m.registerPlugins(m.config.plugins)

        end sub

        ' * Public View Builder methods

        public sub render(payload as object, params = {} as object)
            if Rotor.Utils.isValid(params.callback) then params.callbackScope = m
            m.builder.render(payload, params)
        end sub

        public sub erase(payload as dynamic, shouldSkipNodePool = false as boolean, HID = "0" as string)
            m.builder.erase(payload, shouldSkipNodePool, HID)
        end sub

        public sub registerPlugins(plugins as object)
            m.builder.pluginAdapter.registerPlugins(plugins)
        end sub

        public function findWidgets(searchPattern as string, HID = "0" as string) as object
            return m.builder.widgetTree.find(searchPattern, HID)
        end function

        public function getWidget(searchPattern as string, HID = "0" as string) as object
            return m.builder.widgetTree.get(searchPattern, HID)
        end function

        public function getChildrenWidgets(searchPattern as string, HID = "0" as string) as object
            return m.builder.widgetTree.getChildrenWidgets(searchPattern, HID)
        end function

        public function getWidgetByHID(HID = "0" as string) as object
            return m.builder.widgetTree.getByHID(HID)
        end function

        public function getRootWidget() as object
            return m.builder.widgetTree.getByHID("0")
        end function

        public function getSubtreeClone(searchPattern as string, keyPathList = [] as Object, parentHID = "0" as string) as object
            return m.builder.widgetTree.getSubtreeClone(searchPattern, keyPathList, parentHID)
        end function

        public function getRootNode() as object
            return m.builder.widgetTree.getRootNode()
        end function

        public function getDispatcher(dispatcherId as string) as object
            return m.dispatcherProvider.getFacade(dispatcherId, GetGlobalAA())
        end function

        public function animator(animatorId) as object
            return m.animatorProvider.getFactory(animatorId, m)
        end function

        public function getInfo() as object
            return m.info
        end function

        public function getNodePoolInfo() as object
            return m.builder.nodePool.getNodePoolInfo()
        end function

        public function createNodePool(config) as object
            return m.builder.nodePool.createNodePool(config)
        end function

        sub initInfo()
            ' Device info
            di = CreateObject("roDeviceInfo")
            ' Make it available on framework instance
            m.deviceInfo = di
            ' Generate app info
            m.info.device.append({
                graphicsPlatform: di.GetGraphicsPlatform(), ' ["opengl"|"directfb"]
                modelDisplayName: di.GetModelDisplayName(),
                OSVersion: di.GetOSVersion(),
                currentLocale: di.GetCurrentLocale(), ' Example: "en_US"
                countryCode: di.GetCountryCode() ' A value that indicates the Streaming Store associated with a user’s Roku account.
            })
            #if debug
                print `[DEVICEINFO] Graphics Platform: ${m.info.device.graphicsPlatform}`
                print `[DEVICEINFO] modelDisplayName: ${m.info.device.modelDisplayName}`
                print `[DEVICEINFO] OSVersion: ${m.info.device.OSVersion}`
            #end if
        end sub

        sub setupTaskForSyncing(taskName as string)
            rootNode = m.getRootNode()
            taskNode = rootNode.createChild(taskName)
            taskId = Rotor.Utils.getUUIDHex(16)

            m.taskNodes[taskId] = taskNode ' collection for later usage
            m.taskOperationalFlag[taskId] = false ' collection for later usage

            Rotor.Utils.setCustomFields(taskNode, {
                taskId: taskId,
                rootNode: rootNode
            })

            ' taskNode.observeFieldScoped("rotorSync", "Rotor_syncCallback")
            taskNode.control = "RUN"
        end sub

        sub taskSyncFinished()

            if Rotor.Utils.isFunction(m.config.onTaskReady)
                Rotor.Utils.callbackScoped(m.config.onTaskReady, GetGlobalAA())
            end if
            m.builder.renderQueueFlush()

        end sub


        ' DESTROY
        public sub destroy()

            rootNode = m.getRootNode()
            for each taskId in m.taskNodes
                taskNode = m.taskNodes[taskId]
                taskNode.setField("rotorSync", {
                    type: Rotor.Const.ThreadSyncType.DESTROY
                })
                rootNode.removeChild(taskNode)
            end for


            m.taskNodes.Clear()

            rootNode.unobserveFieldScoped("rotorSync")

            ' destroy subsystems
            m.builder.destroy()
            m.dispatcherProvider.destroy()
            m.i18nService.destroy()

            ' remove references
            m.animatorProvider = invalid
            m.taskNode = invalid
            globalScope = GetGlobalAA()
            globalScope.rotor_framework_helper = {
                frameworkInstance: invalid
            }
            m.config.rootNode = invalid

            m.info.Clear()
            m.deviceInfo = invalid

        end sub

    end class

    sub syncCallback(msg)
        ' extraInfo = msg.GetInfo()
        ' fieldId = msg.getField()
        sync = msg.getData() ' @type:AA

        globalScope = GetGlobalAA()
        m.frameworkInstance = globalScope.rotor_framework_helper.frameworkInstance

        taskNode = sync.taskNode
        taskId = taskNode.taskId

        if sync.type = Rotor.Const.ThreadSyncType.TASK_SYNCING

            ' check additional tasks
            if sync.tasks <> invalid
                taskNames = Rotor.Utils.ensureArray(sync.tasks)
                for each taskName in taskNames
                    m.frameworkInstance.setupTaskForSyncing(taskName)
                end for
            end if

            ' register incoming dispatchers
            dispatcherIds = sync.dispatcherIds
            m.frameworkInstance.dispatcherProvider.registerExternalDispatchers(dispatcherIds, taskNode)


            ' update task status
            taskId = taskNode.taskId
            m.frameworkInstance.taskOperationalFlag[taskId] = true

            ' Check if all nodes ready (very basic logic (< future improvement)
            allTasksRunning = true
            for each flag in m.frameworkInstance.taskOperationalFlag.Items()
                allTasksRunning = allTasksRunning and flag.value
            end for

            ' if allTasksRunning then create external dispatchers in all tasks
            if allTasksRunning = true
                collection = {}
                dispatcherIds = m.frameworkInstance.dispatcherProvider.getAll().keys()
                for each item in m.frameworkInstance.taskNodes.Items()
                    taskNode = item.value
                    for each dispatcherId in dispatcherIds
                        dispatcherInstance = m.frameworkInstance.dispatcherProvider.get(dispatcherId)
                        externalTaskNode = dispatcherInstance.taskNode

                        if not taskNode.isSameNode(externalTaskNode)
                            m.frameworkInstance.taskSyncReadyFlag[taskNode.taskId] = false ' collection for later usage

                            if collection[taskNode.taskId] = invalid then collection[taskNode.taskId] = []

                            collection[taskNode.taskId].push({
                                dispatcherId: dispatcherId,
                                externalTaskNode: externalTaskNode
                            })
                        end if

                    end for
                end for

                if collection.Count() > 0
                    for each taskId in collection
                        taskNode = m.frameworkInstance.taskNodes[taskId]
                        taskNode.setField("rotorSync", {
                            type: Rotor.Const.ThreadSyncType.REGISTER_EXTERNAL_DISPATCHER,
                            externalDispatcherList: collection[taskId]
                        })
                    end for
                else
                    m.frameworkInstance.taskSyncFinished()
                end if

            end if

        else if sync.type = Rotor.Const.ThreadSyncType.TASK_SYNCED

            m.frameworkInstance.taskSyncReadyFlag[taskId] = true
            ' Check if all nodes ready (very basic logic (< future improvement)
            allTasksSynced = true
            for each flag in m.frameworkInstance.taskSyncReadyFlag.Items()
                allTasksSynced = allTasksSynced and flag.value
            end for

            if allTasksSynced = true
                m.frameworkInstance.taskSyncFinished()
            end if

        end if

    end sub



end namespace
